<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta content="en-us" http-equiv="Content-Language" />
<meta content="text/html; charset=utf-8" http-equiv="Content-Type" />
<title>Unity Prolog Reference</title>
<style type="text/css">
.dullCode {
font-family: "Courier New", Courier, monospace;
}
.procedureName {
font-family: "Courier New", Courier, monospace;
font-weight:bold;
}
.argument {
font-family: "Times New Roman", Times, serif;
font-style:italic;
}
</style>
</head>
<body>
<h1><a name="Unity Prolog Reference">Unity Prolog Reference</a></h1><ul>
<li><a href="#Flow control">Flow control</a></li><li><a href="#Meta-logical predicates">Meta-logical predicates</a></li><li><a href="#All solutions predicates">All solutions predicates</a></li><li><a href="#Arithmetic">Arithmetic</a></li><li><a href="#Comparisons">Comparisons</a></li><li><a href="#List predicates">List predicates</a></li><li><a href="#Term manipulation">Term manipulation</a></li><li><a href="#Type predicates">Type predicates</a></li><li><a href="#Constraint programming">Constraint programming</a></li><li><a href="#.NET interoperation">.NET interoperation</a></li><li><a href="#Declarations">Declarations</a></li><li><a href="#Definite clause grammars">Definite clause grammars</a></li><li><a href="#Loading code">Loading code</a></li><li><a href="#Database manipulation">Database manipulation</a></li><li><a href="#eremic logic">eremic logic</a></li><li><a href="#Other Predicates">Other Predicates</a></li></ul>
<h2><a name="Flow control">Flow control</a></h2><dl><dt><span class="dullCode"><span class="procedureName">,</span>(<span class="argument">:goal1</span>,&nbsp;<span class="argument">:goal2</span>)</span></dt><dd>True if both goals are true.</dd><dt><span class="dullCode"><span class="procedureName">;</span>(<span class="argument">:goal1</span>,&nbsp;<span class="argument">:goal2</span>)</span></dt><dd>True if both goals are true.</dd><dt><span class="dullCode"><span class="procedureName">-&gt;</span>(<span class="argument">:test</span>,&nbsp;<span class="argument">:consequent</span>)</span></dt><dd>Proves CONSEQUENT if TEST is true.</dd><dt><span class="dullCode"><span class="procedureName">not</span>(<span class="argument">*goal</span>)</span></dt><dd>True if GOAL is unprovable.  GOAL must be ground.</dd><dt><span class="dullCode"><span class="procedureName">\+</span>(<span class="argument">:goal</span>)</span></dt><dd>True if GOAL is unprovable</dd><dt><span class="dullCode"><span class="procedureName">once</span>(<span class="argument">:goal</span>)</span></dt><dd>Attempts to prove GOAL, but suppresses backtracking for a second solution.</dd><dt><span class="dullCode"><span class="procedureName">ignore</span>(<span class="argument">:goals</span>,&nbsp;<span class="argument">&hellip;</span>)</span></dt><dd>Attempts to prove GOAL, but suppresses backtracking for a second solution.</dd><dt><span class="dullCode"><span class="procedureName">call</span>(<span class="argument">:goal</span>,&nbsp;<span class="argument">?optionalArguments</span>,&nbsp;<span class="argument">&hellip;</span>)</span></dt><dd>Attempts to prove the specified GOAL, adding any additional arguments, if specified.</dd><dt><span class="dullCode"><span class="procedureName">apply</span>(<span class="argument">:goal</span>,&nbsp;<span class="argument">+arglist</span>)</span></dt><dd>Adds arguments in ARGLIST to end of GOAL and attempts to prove the resulting goal.</dd><dt><span class="dullCode"><span class="procedureName">begin</span>(<span class="argument">:goal</span>,&nbsp;<span class="argument">&hellip;</span>)</span></dt><dd>Runs each goal in sequence, throwing an exception if any goal fails.  Cannot be backtracked.</dd><dt><span class="dullCode"><span class="procedureName">.</span>(<span class="argument">*object</span>,&nbsp;<span class="argument">method(*arguments...)</span>)</span></dt><dd>Calls the specified method of the specified object.</dd><dt><span class="dullCode"><span class="procedureName">::</span>(<span class="argument">*module</span>,&nbsp;<span class="argument">:goal</span>)</span></dt><dd>Attempts to prove the specified goal in the specified module.</dd><dt><span class="dullCode"><span class="procedureName">freeze</span>(<span class="argument">?var</span>,&nbsp;<span class="argument">:goal</span>)</span></dt><dd>Runs GOAL when VAR becomes bound; unification will fail if GOAL fails.</dd><dt><span class="dullCode"><span class="procedureName">frozen</span>(<span class="argument">?term</span>,&nbsp;<span class="argument">-goal</span>)</span></dt><dd>Unifies GOAL with the goal frozen on TERM, if TERM is an unbound variable with a frozen goal; otherwise unifies GOAL with true.</dd><dt><span class="dullCode"><span class="procedureName">randomizable</span>(<span class="argument">:predicateIndicator</span>,&nbsp;<span class="argument">&hellip;</span>)</span></dt><dd>Declares that the specified predicate is allowed to have its clauses explored in random order, when clause randomization is enabled.</dd><dt><span class="dullCode"><span class="procedureName">shadow</span>(<span class="argument">:predicateIndicator</span>,&nbsp;<span class="argument">&hellip;</span>)</span></dt><dd>Declares that declarations for the specified predicate are allowed in this knowledgebase and override any declarations in the parent.</dd><dt><span class="dullCode"><span class="procedureName">external</span>(<span class="argument">:predicateIndicator</span>,&nbsp;<span class="argument">&hellip;</span>)</span></dt><dd>Declares that the specified predicate is optional to define and/or defined elsewhere; thus, it should not generate undefined predicate warnings.</dd><dt><span class="dullCode"><span class="procedureName">public</span>(<span class="argument">:predicateIndicator</span>,&nbsp;<span class="argument">&hellip;</span>)</span></dt><dd>Declares that the specified predicate is expected to be called from elsewhere.  It should not generate unreferenced predicate warnings.</dd><dt><span class="dullCode"><span class="procedureName">higher_order</span>(<span class="argument">:predicateIndicator</span>,&nbsp;<span class="argument">&hellip;</span>)</span></dt><dd>Declares that the specified predicate is may call its arguments as subgoals.  For example, higher_order(find_all(0,1,0)) means find_all/3 calls its second argument.  Used by the static checker to weed out unreferenced predicates.</dd><dt><span class="dullCode"><span class="procedureName">disassemble</span>(<span class="argument">:predicateIndicator</span>,&nbsp;<span class="argument">&hellip;</span>)</span></dt><dd>Prints bytecode for a compiled predicate.</dd><dt><span class="dullCode"><span class="procedureName">compile</span>(<span class="argument">:predicateIndicator</span>,&nbsp;<span class="argument">&hellip;</span>)</span></dt><dd>Declares that the predicate should be byte compiled rather than interpreted.</dd><dt><span class="dullCode"><span class="procedureName">trace</span>(<span class="argument">:predicateIndicator</span>,&nbsp;<span class="argument">&hellip;</span>)</span></dt><dd>Declares that the specified predicate should be traced when executing.</dd><dt><span class="dullCode"><span class="procedureName">notrace</span>(<span class="argument">:predicateIndicator</span>,&nbsp;<span class="argument">&hellip;</span>)</span></dt><dd>Declares that the specified predicate should be traced when executing.</dd><dt><span class="dullCode"><span class="procedureName">pause_game</span>(<span class="argument">:predicateIndicator</span>,&nbsp;<span class="argument">&hellip;</span>)</span></dt><dd>Pauses the game, leaving GUI, etc. running.</dd><dt><span class="dullCode"><span class="procedureName">unpause_game</span>(<span class="argument">:predicateIndicator</span>,&nbsp;<span class="argument">&hellip;</span>)</span></dt><dd>Restores normal flow of time in game.</dd><dt><span class="dullCode"><span class="procedureName">!</span></span></dt><dd>Prohibits backtracking past this point for the current goal.</dd><dt><span class="dullCode"><span class="procedureName">fail</span></span></dt><dd>Forces failure of the current goal.</dd><dt><span class="dullCode"><span class="procedureName">true</span></span></dt><dd>Always succeeds.</dd><dt><span class="dullCode"><span class="procedureName">repeat</span></span></dt><dd>Always succeeds, and allows infinite backtracking.</dd><dt><span class="dullCode"><span class="procedureName">throw</span>(<span class="argument">+exception</span>)</span></dt><dd>Throws the specified exception.</dd><dt><span class="dullCode"><span class="procedureName">catch</span>(<span class="argument">:goal</span>,&nbsp;<span class="argument">=exception</span>,&nbsp;<span class="argument">:recover</span>)</span></dt><dd>Attempts to prove the specified GOAL, catching exceptions.  If an exception is thrown, it is unified with EXCEPTION and RECOVER is run.</dd><dt><span class="dullCode"><span class="procedureName">break</span>(<span class="argument">?Term</span>,&nbsp;<span class="argument">&hellip;</span>)</span></dt><dd>Pauses game within the Unity editor and prints TERMS as a line in the unity console.</dd><dt><span class="dullCode"><span class="procedureName">break_cs</span></span></dt><dd>Breakpoints the Prolog interpreter itself.</dd></dl>
<h2><a name="Meta-logical predicates">Meta-logical predicates</a></h2><dl><dt><span class="dullCode"><span class="procedureName">once</span>(<span class="argument">:goal</span>)</span></dt><dd>Attempts to prove GOAL, but suppresses backtracking for a second solution.</dd><dt><span class="dullCode"><span class="procedureName">ignore</span>(<span class="argument">:goals</span>,&nbsp;<span class="argument">&hellip;</span>)</span></dt><dd>Attempts to prove GOAL, but suppresses backtracking for a second solution.</dd><dt><span class="dullCode"><span class="procedureName">call</span>(<span class="argument">:goal</span>,&nbsp;<span class="argument">?optionalArguments</span>,&nbsp;<span class="argument">&hellip;</span>)</span></dt><dd>Attempts to prove the specified GOAL, adding any additional arguments, if specified.</dd><dt><span class="dullCode"><span class="procedureName">apply</span>(<span class="argument">:goal</span>,&nbsp;<span class="argument">+arglist</span>)</span></dt><dd>Adds arguments in ARGLIST to end of GOAL and attempts to prove the resulting goal.</dd><dt><span class="dullCode"><span class="procedureName">randomize</span>(<span class="argument">:goal</span>)</span></dt><dd>Proves GOAL, while randomizing clause order for clauses declared randomizable.</dd><dt><span class="dullCode"><span class="procedureName">begin</span>(<span class="argument">:goal</span>,&nbsp;<span class="argument">&hellip;</span>)</span></dt><dd>Runs each goal in sequence, throwing an exception if any goal fails.  Cannot be backtracked.</dd><dt><span class="dullCode"><span class="procedureName">maplist</span>(<span class="argument">:predicate</span>,&nbsp;<span class="argument">?list1</span>,&nbsp;<span class="argument">?list2</span>)</span></dt><dd>True if PREDICATE is true of all successive pairs of elements from LIST1 and LIST2.</dd><dt><span class="dullCode"><span class="procedureName">!</span></span></dt><dd>Prohibits backtracking past this point for the current goal.</dd><dt><span class="dullCode"><span class="procedureName">throw</span>(<span class="argument">+exception</span>)</span></dt><dd>Throws the specified exception.</dd><dt><span class="dullCode"><span class="procedureName">catch</span>(<span class="argument">:goal</span>,&nbsp;<span class="argument">=exception</span>,&nbsp;<span class="argument">:recover</span>)</span></dt><dd>Attempts to prove the specified GOAL, catching exceptions.  If an exception is thrown, it is unified with EXCEPTION and RECOVER is run.</dd><dt><span class="dullCode"><span class="procedureName">var</span>(<span class="argument">?x</span>)</span></dt><dd>True if X is an uninstantiated variable.</dd><dt><span class="dullCode"><span class="procedureName">nonvar</span>(<span class="argument">?x</span>)</span></dt><dd>True if X isn't an uninstantiated variable, that is, if it's instantiated to some term.</dd><dt><span class="dullCode"><span class="procedureName">ground</span>(<span class="argument">?x</span>)</span></dt><dd>True if X is a ground term, i.e. contains no unbound variables.</dd><dt><span class="dullCode"><span class="procedureName">set</span>(<span class="argument">*predicate</span>,&nbsp;<span class="argument">*value</span>)</span></dt><dd>Forcibly asserts PREDICATE(VALUE) and retracts all other clauses for PREDICATE.</dd></dl>
<h2><a name="All solutions predicates">All solutions predicates</a></h2><dl><dt><span class="dullCode"><span class="procedureName">forall</span>(<span class="argument">:generator</span>,&nbsp;<span class="argument">:goal</span>)</span></dt><dd>True if GOAL is true for all bindings of all solutions of GENERATOR.</dd><dt><span class="dullCode"><span class="procedureName">for_all_unique</span>(<span class="argument">-Template</span>,&nbsp;<span class="argument">:generator</span>,&nbsp;<span class="argument">:goal</span>)</span></dt><dd>True if GOAL is true given variable bindings of each unique value of TEMPLATE produced by GENERATOR.</dd><dt><span class="dullCode"><span class="procedureName">generate_unique</span>(<span class="argument">-Template</span>,&nbsp;<span class="argument">:generator</span>)</span></dt><dd>Succeeds once for each unique value of TEMPLATE produced by GENERATOR.</dd><dt><span class="dullCode"><span class="procedureName">findall</span>(<span class="argument">=template</span>,&nbsp;<span class="argument">:goal</span>,&nbsp;<span class="argument">-solutions</span>)</span></dt><dd>Unifies SOLUTIONS with a list of every value of TEMPLATE for every possible solution of GOAL.</dd><dt><span class="dullCode"><span class="procedureName">findnsols</span>(<span class="argument">*n</span>,&nbsp;<span class="argument">=template</span>,&nbsp;<span class="argument">:goal</span>,&nbsp;<span class="argument">-solutions</span>)</span></dt><dd>Unifies SOLUTIONS with a list of every value of TEMPLATE for every possible solution of GOAL.  Finds at most N solutiosn.</dd><dt><span class="dullCode"><span class="procedureName">all</span>(<span class="argument">=template</span>,&nbsp;<span class="argument">:goal</span>,&nbsp;<span class="argument">-solutions</span>)</span></dt><dd>Unifies SOLUTIONS with a list of every unique value of TEMPLATE for every possible solution of GOAL.</dd><dt><span class="dullCode"><span class="procedureName">sumall</span>(<span class="argument">-numberVar</span>,&nbsp;<span class="argument">:goal</span>,&nbsp;<span class="argument">-sum</span>)</span></dt><dd>Unifies SUM with sum of the values of NUMBERVAR in every possible solution of GOAL.</dd><dt><span class="dullCode"><span class="procedureName">arg_min</span>(<span class="argument">&gt;template</span>,&nbsp;<span class="argument">-score</span>,&nbsp;<span class="argument">+goal</span>)</span></dt><dd>Find the value of TEMPLATE that gives the lowest SCORE among all solutions to GOAL.</dd><dt><span class="dullCode"><span class="procedureName">arg_max</span>(<span class="argument">&gt;template</span>,&nbsp;<span class="argument">-score</span>,&nbsp;<span class="argument">+goal</span>)</span></dt><dd>Find the value of TEMPLATE that gives the highest SCORE among all solutions to GOAL.</dd></dl>
<h2><a name="Arithmetic">Arithmetic</a></h2><dl><dt><span class="dullCode"><span class="procedureName">is</span>(<span class="argument">&gt;variable</span>,&nbsp;<span class="argument">*functional_expression</span>)</span></dt><dd>Computes the value of FUNCTIONAL_EXPRESSION and unifies it with VARIABLE.  Expression must be fully instantiated, i.e. all variables in it must already have values.</dd></dl>
<h2><a name="Comparisons">Comparisons</a></h2><dl><dt><span class="dullCode"><span class="procedureName">dif</span>(<span class="argument">?term1</span>,&nbsp;<span class="argument">?term2</span>)</span></dt><dd>Requires that TERM1 and TERM2 never be equal.  If they are, the predicate fails.  If they are not, it forces any future unifications that would make them equal to fail.</dd><dt><span class="dullCode"><span class="procedureName">=</span>(<span class="argument">?x</span>,&nbsp;<span class="argument">?y</span>)</span></dt><dd>Succeeds if the two terms are unifiable.</dd><dt><span class="dullCode"><span class="procedureName">unifiable</span>(<span class="argument">?x</span>,&nbsp;<span class="argument">?y</span>,&nbsp;<span class="argument">-unifier</span>)</span></dt><dd>True if X and Y can be unified, but does not unify them.  Instead returns the most general unifier in UNIFIER.</dd><dt><span class="dullCode"><span class="procedureName">\=</span>(<span class="argument">?x</span>,&nbsp;<span class="argument">?y</span>)</span></dt><dd>Succeeds if the two terms are not unifiable.</dd><dt><span class="dullCode"><span class="procedureName">==</span>(<span class="argument">?x</span>,&nbsp;<span class="argument">?y</span>)</span></dt><dd>Succeeds if the two terms are already identical, as opposed to =, which tries to make them identical through unification.</dd><dt><span class="dullCode"><span class="procedureName">\==</span>(<span class="argument">?x</span>,&nbsp;<span class="argument">?y</span>)</span></dt><dd>Succeeds if the two terms are not identical, as opposed to \= which tests if it's possible to make them identical through unification.</dd><dt><span class="dullCode"><span class="procedureName">&lt;</span>(<span class="argument">*x</span>,&nbsp;<span class="argument">*y</span>)</span></dt><dd>True if number X is less than Y.  Both must be ground.</dd><dt><span class="dullCode"><span class="procedureName">&gt;</span>(<span class="argument">*x</span>,&nbsp;<span class="argument">*y</span>)</span></dt><dd>True if number X is greater than Y.  Both must be ground.</dd><dt><span class="dullCode"><span class="procedureName">=&lt;</span>(<span class="argument">*x</span>,&nbsp;<span class="argument">*y</span>)</span></dt><dd>True if number X is less than or equal to Y.  Both must be ground.</dd><dt><span class="dullCode"><span class="procedureName">&gt;=</span>(<span class="argument">*x</span>,&nbsp;<span class="argument">*y</span>)</span></dt><dd>True if number X is greater than or equal to Y.  Both must be ground.</dd><dt><span class="dullCode"><span class="procedureName">@&lt;</span>(<span class="argument">?x</span>,&nbsp;<span class="argument">?y</span>)</span></dt><dd>True if term X is less than Y given Prolog's ordering on terms.  X and Y need not be numbers.</dd><dt><span class="dullCode"><span class="procedureName">@&gt;</span>(<span class="argument">?x</span>,&nbsp;<span class="argument">?y</span>)</span></dt><dd>True if term X is greater than Y given Prolog's ordering on terms.  X and Y need not be numbers.</dd><dt><span class="dullCode"><span class="procedureName">@=&lt;</span>(<span class="argument">?x</span>,&nbsp;<span class="argument">?y</span>)</span></dt><dd>True if term X is less than or equal to Y given Prolog's ordering on terms.  X and Y need not be numbers.</dd><dt><span class="dullCode"><span class="procedureName">@&gt;=</span>(<span class="argument">?x</span>,&nbsp;<span class="argument">?y</span>)</span></dt><dd>True if term X is greater than or equal to Y given Prolog's ordering on terms.  X and Y need not be numbers.</dd><dt><span class="dullCode"><span class="procedureName">=\=</span>(<span class="argument">*x</span>,&nbsp;<span class="argument">*y</span>)</span></dt><dd>True if X and Y are different numbers.  Both must be ground.</dd><dt><span class="dullCode"><span class="procedureName">=:=</span>(<span class="argument">*x</span>,&nbsp;<span class="argument">*y</span>)</span></dt><dd>True if functional expressions X and Y have the same values.  Both must be ground.</dd></dl>
<h2><a name="List predicates">List predicates</a></h2><dl><dt><span class="dullCode"><span class="procedureName">maplist</span>(<span class="argument">:predicate</span>,&nbsp;<span class="argument">?list1</span>,&nbsp;<span class="argument">?list2</span>)</span></dt><dd>True if PREDICATE is true of all successive pairs of elements from LIST1 and LIST2.</dd><dt><span class="dullCode"><span class="procedureName">=..</span>(<span class="argument">?term</span>,&nbsp;<span class="argument">?list</span>)</span></dt><dd>If TERM is instantiated, explodes it into a list: [Functor | Arguments] and unifies it with LIST; if TERM uninstantiated, converts LIST to a term and unifies it with TERM.</dd><dt><span class="dullCode"><span class="procedureName">list</span>(<span class="argument">?x</span>)</span></dt><dd>True if X is a list.</dd><dt><span class="dullCode"><span class="procedureName">length</span>(<span class="argument">?list</span>,&nbsp;<span class="argument">?length</span>)</span></dt><dd>Unifies LENGTH with the length of LIST.  This is a true relation, so if LIST is uninstantiated, it will create lists with specified lengths.</dd><dt><span class="dullCode"><span class="procedureName">member</span>(<span class="argument">?element</span>,&nbsp;<span class="argument">?list</span>)</span></dt><dd>True if ELEMENT is an element of LIST.  This is a true relation, so if necessary, it will create new LISTS.</dd><dt><span class="dullCode"><span class="procedureName">memberchk</span>(<span class="argument">?element</span>,&nbsp;<span class="argument">?list</span>)</span></dt><dd>True if ELEMENT is an element of LIST, but will not backtrack different choices of the element.  This is a true relation, so if necessary, it will create new LISTS.</dd><dt><span class="dullCode"><span class="procedureName">random_member</span>(<span class="argument">?element</span>,&nbsp;<span class="argument">+list</span>)</span></dt><dd>Unifies ELEMENT with elements of LIST in random order.</dd><dt><span class="dullCode"><span class="procedureName">append</span>(<span class="argument">?start</span>,&nbsp;<span class="argument">?end</span>,&nbsp;<span class="argument">?joined</span>)</span></dt><dd>True if JOINED is a list that starts with the elements of START and is followed by the elements of END.  This is a true relation, so it can be used to compute any argument from the others.</dd><dt><span class="dullCode"><span class="procedureName">reverse</span>(<span class="argument">?forward</span>,&nbsp;<span class="argument">?backward</span>)</span></dt><dd>True if the lists FORWARD and BACKWARD are reversed versions of one another.</dd><dt><span class="dullCode"><span class="procedureName">flatten</span>(<span class="argument">+listoflists</span>,&nbsp;<span class="argument">?flatlist</span>)</span></dt><dd>True if FLATLIST contains all the atoms of LISTOFLISTS, in order.</dd><dt><span class="dullCode"><span class="procedureName">prefix</span>(<span class="argument">?prefix</span>,&nbsp;<span class="argument">?list</span>)</span></dt><dd>True if LIST starts with PREFIX.</dd><dt><span class="dullCode"><span class="procedureName">suffix</span>(<span class="argument">?suffix</span>,&nbsp;<span class="argument">?list</span>)</span></dt><dd>True if LIST ends with SUFFIX.</dd><dt><span class="dullCode"><span class="procedureName">select</span>(<span class="argument">?x</span>,&nbsp;<span class="argument">?list_with</span>,&nbsp;<span class="argument">?list_without</span>)</span></dt><dd>True if X is an element of LIST_WITH and LIST_WITHOUT is LIST_WITH minus an occurance of X.</dd><dt><span class="dullCode"><span class="procedureName">delete</span>(<span class="argument">?list</span>,&nbsp;<span class="argument">?x</span>,&nbsp;<span class="argument">?HasNoXs</span>)</span></dt><dd>True if HasNoXs is LIST without X.</dd><dt><span class="dullCode"><span class="procedureName">msort</span>(<span class="argument">+list</span>,&nbsp;<span class="argument">-result</span>)</span></dt><dd>True if RESULT is unifiable with a sorted version of LIST.  Does not remove duplicates.</dd><dt><span class="dullCode"><span class="procedureName">sort</span>(<span class="argument">+list</span>,&nbsp;<span class="argument">-result</span>)</span></dt><dd>True if RESULT is unifiable with a sorted version of LIST.  Removes duplicates.</dd><dt><span class="dullCode"><span class="procedureName">keysort</span>(<span class="argument">+list</span>,&nbsp;<span class="argument">-result</span>)</span></dt><dd>LIST should be of the format [KEY-VALUE, ...].  True if RESULT is unifiable with a version of LIST sorted by its KEYs.  Does not remove duplicates.</dd></dl>
<h2><a name="Term manipulation">Term manipulation</a></h2><dl><dt><span class="dullCode"><span class="procedureName">indexical_named</span>(<span class="argument">?name</span>,&nbsp;<span class="argument">?indexical</span>)</span></dt><dd>The INDEXICAL is an indexical object with name NAME.</dd><dt><span class="dullCode"><span class="procedureName">copy_term</span>(<span class="argument">=original</span>,&nbsp;<span class="argument">-copy</span>)</span></dt><dd>Makes a new copy of ORIGINAL with fresh variables, and unifies it with COPY.</dd><dt><span class="dullCode"><span class="procedureName">=..</span>(<span class="argument">?term</span>,&nbsp;<span class="argument">?list</span>)</span></dt><dd>If TERM is instantiated, explodes it into a list: [Functor | Arguments] and unifies it with LIST; if TERM uninstantiated, converts LIST to a term and unifies it with TERM.</dd><dt><span class="dullCode"><span class="procedureName">functor</span>(<span class="argument">?term</span>,&nbsp;<span class="argument">?functor</span>,&nbsp;<span class="argument">?arity</span>)</span></dt><dd>True if TERM has the specified FUNCTOR and ARITY.</dd><dt><span class="dullCode"><span class="procedureName">arg</span>(<span class="argument">*arg</span>,&nbsp;<span class="argument">+structure</span>,&nbsp;<span class="argument">?argumentValue</span>)</span></dt><dd>True if argument number ARG (counting from 1, not zero) of STRUCTURE is TERM.</dd></dl>
<h2><a name="Type predicates">Type predicates</a></h2><dl><dt><span class="dullCode"><span class="procedureName">number</span>(<span class="argument">?x</span>)</span></dt><dd>True if X is a number.</dd><dt><span class="dullCode"><span class="procedureName">integer</span>(<span class="argument">?x</span>)</span></dt><dd>True if X is an integer.</dd><dt><span class="dullCode"><span class="procedureName">float</span>(<span class="argument">?x</span>)</span></dt><dd>True if X is a floating-point number.</dd><dt><span class="dullCode"><span class="procedureName">atomic</span>(<span class="argument">?x</span>)</span></dt><dd>True if X is not a structured term, i.e. it's a number, symbol, etc..</dd><dt><span class="dullCode"><span class="procedureName">string</span>(<span class="argument">?x</span>)</span></dt><dd>True if X is a string.</dd><dt><span class="dullCode"><span class="procedureName">atom</span>(<span class="argument">?x</span>)</span></dt><dd>True if X is a symbol.</dd><dt><span class="dullCode"><span class="procedureName">symbol</span>(<span class="argument">?x</span>)</span></dt><dd>True if X is a symbol.</dd><dt><span class="dullCode"><span class="procedureName">compound</span>(<span class="argument">?x</span>)</span></dt><dd>True if X is a structured term or list.</dd></dl>
<h2><a name="Constraint programming">Constraint programming</a></h2><dl><dt><span class="dullCode"><span class="procedureName">freeze</span>(<span class="argument">?var</span>,&nbsp;<span class="argument">:goal</span>)</span></dt><dd>Runs GOAL when VAR becomes bound; unification will fail if GOAL fails.</dd><dt><span class="dullCode"><span class="procedureName">frozen</span>(<span class="argument">?term</span>,&nbsp;<span class="argument">-goal</span>)</span></dt><dd>Unifies GOAL with the goal frozen on TERM, if TERM is an unbound variable with a frozen goal; otherwise unifies GOAL with true.</dd><dt><span class="dullCode"><span class="procedureName">dif</span>(<span class="argument">?term1</span>,&nbsp;<span class="argument">?term2</span>)</span></dt><dd>Requires that TERM1 and TERM2 never be equal.  If they are, the predicate fails.  If they are not, it forces any future unifications that would make them equal to fail.</dd></dl>
<h2><a name=".NET interoperation">.NET interoperation</a></h2><dl><dt><span class="dullCode"><span class="procedureName">property</span>(<span class="argument">*object</span>,&nbsp;<span class="argument">*property_name</span>,&nbsp;<span class="argument">&gt;value</span>)</span></dt><dd>Unifies VALUE with the value of OBJECT's property named PROPERTY_NAME.Always succeeds exactly once (unless it throws an exception).</dd><dt><span class="dullCode"><span class="procedureName">set_property</span>(<span class="argument">*object</span>,&nbsp;<span class="argument">*property_name</span>,&nbsp;<span class="argument">*new_value</span>)</span></dt><dd>Sets OBJECT's property named PROPERTY_NAME to NEW_VALUE.  Always succeeds exactly once (unless it throws an exception).</dd><dt><span class="dullCode"><span class="procedureName">call_method</span>(<span class="argument">*object</span>,&nbsp;<span class="argument">*method_and_args</span>,&nbsp;<span class="argument">&gt;result</span>)</span></dt><dd>Calls the specified method on OBJECT with the specified arguments and unifies RESULT with its return value.  Always succeeds exactly once (unless it throws an exception).</dd><dt><span class="dullCode"><span class="procedureName">is_class</span>(<span class="argument">?object</span>,&nbsp;<span class="argument">?class</span>)</span></dt><dd>True if OBJECT is of the specified CLASS.  If CLASS is a subclass of TwigGameComponent and OBJECT is uninstantiated, then it will enumerate objects if the specified type.</dd><dt><span class="dullCode"><span class="procedureName">component_of_gameobject_with_type</span>(<span class="argument">?component</span>,&nbsp;<span class="argument">?gameobject</span>,&nbsp;<span class="argument">+class</span>)</span></dt><dd>True if component is a component of gameobject with type class.</dd><dt><span class="dullCode"><span class="procedureName">parent_of_gameobject</span>(<span class="argument">?child</span>,&nbsp;<span class="argument">?parent</span>)</span></dt><dd>True if CHILD is a child of PARENT in the game's rendering hierarchy.</dd></dl>
<h2><a name="Declarations">Declarations</a></h2><dl><dt><span class="dullCode"><span class="procedureName">bind</span>(<span class="argument">*IndexicalName</span>,&nbsp;<span class="argument">=Value</span>)</span></dt><dd>Dynamically binds IndexicalName to Value until this goal is backtracked.</dd><dt><span class="dullCode"><span class="procedureName">indexical</span>(<span class="argument">*Name=*DefaultValue</span>)</span></dt><dd>Declares that the specified name is an indexical name that can be bound using bind.</dd><dt><span class="dullCode"><span class="procedureName">randomizable</span>(<span class="argument">:predicateIndicator</span>,&nbsp;<span class="argument">&hellip;</span>)</span></dt><dd>Declares that the specified predicate is allowed to have its clauses explored in random order, when clause randomization is enabled.</dd><dt><span class="dullCode"><span class="procedureName">shadow</span>(<span class="argument">:predicateIndicator</span>,&nbsp;<span class="argument">&hellip;</span>)</span></dt><dd>Declares that declarations for the specified predicate are allowed in this knowledgebase and override any declarations in the parent.</dd><dt><span class="dullCode"><span class="procedureName">external</span>(<span class="argument">:predicateIndicator</span>,&nbsp;<span class="argument">&hellip;</span>)</span></dt><dd>Declares that the specified predicate is optional to define and/or defined elsewhere; thus, it should not generate undefined predicate warnings.</dd><dt><span class="dullCode"><span class="procedureName">public</span>(<span class="argument">:predicateIndicator</span>,&nbsp;<span class="argument">&hellip;</span>)</span></dt><dd>Declares that the specified predicate is expected to be called from elsewhere.  It should not generate unreferenced predicate warnings.</dd><dt><span class="dullCode"><span class="procedureName">higher_order</span>(<span class="argument">:predicateIndicator</span>,&nbsp;<span class="argument">&hellip;</span>)</span></dt><dd>Declares that the specified predicate is may call its arguments as subgoals.  For example, higher_order(find_all(0,1,0)) means find_all/3 calls its second argument.  Used by the static checker to weed out unreferenced predicates.</dd><dt><span class="dullCode"><span class="procedureName">predicate_property</span>(<span class="argument">:goal</span>,&nbsp;<span class="argument">+property</span>)</span></dt><dd>True if PROPERTY holds of the predicate of GOAL.</dd><dt><span class="dullCode"><span class="procedureName">discontiguous</span>(<span class="argument">:predicateIndicator</span>,&nbsp;<span class="argument">&hellip;</span>)</span></dt><dd>Declares that the specified predicate is allowed to be scattered through a file.  Currently unused but provided for compatibility with other Prolog implementation.</dd><dt><span class="dullCode"><span class="procedureName">multifile</span>(<span class="argument">:predicateIndicator</span>,&nbsp;<span class="argument">&hellip;</span>)</span></dt><dd>Declares that the specified predicate is allowed to be scattered through multiple files.  Currently unused but provided for compatibility with other Prolog implementation.</dd><dt><span class="dullCode"><span class="procedureName">dynamic</span>(<span class="argument">:predicateIndicator</span>,&nbsp;<span class="argument">&hellip;</span>)</span></dt><dd>Declares that the specified predicate is allowed be dynamically modified using assert.  Currently unused but provided for compatibility with other Prolog implementation.</dd><dt><span class="dullCode"><span class="procedureName">trace</span>(<span class="argument">:predicateIndicator</span>,&nbsp;<span class="argument">&hellip;</span>)</span></dt><dd>Declares that the specified predicate should be traced when executing.</dd><dt><span class="dullCode"><span class="procedureName">notrace</span>(<span class="argument">:predicateIndicator</span>,&nbsp;<span class="argument">&hellip;</span>)</span></dt><dd>Declares that the specified predicate should be traced when executing.</dd><dt><span class="dullCode"><span class="procedureName">set_prolog_flag</span>(<span class="argument">*flag</span>,&nbsp;<span class="argument">?value</span>)</span></dt><dd>Sets/gets value of the specified control parameter for the prolog system.</dd><dt><span class="dullCode"><span class="procedureName">op</span>(<span class="argument">*priority</span>,&nbsp;<span class="argument">*type</span>,&nbsp;<span class="argument">*operator</span>)</span></dt><dd>Declares the type and priority of an infix, prefix, or postfix operator.</dd></dl>
<h2><a name="Definite clause grammars">Definite clause grammars</a></h2><dl><dt><span class="dullCode"><span class="procedureName">C</span>(<span class="argument">?list</span>,&nbsp;<span class="argument">?word</span>,&nbsp;<span class="argument">?tail</span>)</span></dt><dd>Used in implementation of DGCs.  True if LIST starts with WORD and continues with TAIL.</dd><dt><span class="dullCode"><span class="procedureName">word_list</span>(<span class="argument">?string</span>,&nbsp;<span class="argument">?list</span>)</span></dt><dd>Parses/unparses STRING into a LIST of word.</dd><dt><span class="dullCode"><span class="procedureName">register_lexical_item</span>(<span class="argument">+word</span>)</span></dt><dd>Adds WORD to list of words recognized by word_list.</dd></dl>
<h2><a name="Loading code">Loading code</a></h2><dl><dt><span class="dullCode"><span class="procedureName">consult</span>(<span class="argument">*file</span>,&nbsp;<span class="argument">[kb]</span>)</span></dt><dd>Reads the clauses in FILE and addds them to the database.</dd><dt><span class="dullCode"><span class="procedureName">reconsult</span>(<span class="argument">*file</span>)</span></dt><dd>Removes all clauses previously loaded from FILE, then reads the clauses in FILE and addds them to the database.</dd><dt><span class="dullCode"><span class="procedureName">listing</span>(<span class="argument">*predicate</span>)</span></dt><dd>Prints a listing of PREDICATE</dd></dl>
<h2><a name="Database manipulation">Database manipulation</a></h2><dl><dt><span class="dullCode"><span class="procedureName">listing</span>(<span class="argument">*predicate</span>)</span></dt><dd>Prints a listing of PREDICATE</dd><dt><span class="dullCode"><span class="procedureName">asserta</span>(<span class="argument">+term</span>)</span></dt><dd>Adds TERM (a rule or fact) to the database as the first clause for the predicate.</dd><dt><span class="dullCode"><span class="procedureName">assert</span>(<span class="argument">+term</span>)</span></dt><dd>Adds TERM (a rule or fact) to the database as the last clause for the predicate.  Same as assertz.</dd><dt><span class="dullCode"><span class="procedureName">assert</span>(<span class="argument">+term</span>)</span></dt><dd>Adds TERM (a rule or fact) to the database as the last clause for the predicate.  Same as assertz.</dd><dt><span class="dullCode"><span class="procedureName">retractall</span>(<span class="argument">+head</span>)</span></dt><dd>Removes all database entries whose heads unify with HEAD.</dd><dt><span class="dullCode"><span class="procedureName">retract</span>(<span class="argument">+term</span>)</span></dt><dd>Removes first database entry that unifies with TERM.</dd><dt><span class="dullCode"><span class="procedureName">clause</span>(<span class="argument">+head</span>,&nbsp;<span class="argument">?body</span>)</span></dt><dd>Unifies HEAD and BODY with entries in the database.</dd></dl>
<h2><a name="eremic logic">eremic logic</a></h2><dl><dt><span class="dullCode"><span class="procedureName">/</span>(<span class="argument">parent</span>,&nbsp;<span class="argument">key</span>)</span></dt><dd>Succeeds if expression can be matched against the EL knowledgebase.</dd><dt><span class="dullCode"><span class="procedureName">:</span>(<span class="argument">parent</span>,&nbsp;<span class="argument">key</span>)</span></dt><dd>Succeeds if expression can be matched against the EL knowledgebase.</dd><dt><span class="dullCode"><span class="procedureName">&gt;&gt;</span>(<span class="argument">*expression</span>,&nbsp;<span class="argument">-variable</span>)</span></dt><dd>Binds VARIABLE to the subtree of the EL KB matching EXPRESSION.</dd></dl>
<h2><a name="Other Predicates">Other Predicates</a></h2><dl><dt><span class="dullCode"><span class="procedureName">check</span>(<span class="argument">:goal</span>)</span></dt><dd>Checks that Goal is true, and throws an exception if it fails.  Only succeeds once, so similar to once/1.</dd><dt><span class="dullCode"><span class="procedureName">step_limit</span>(<span class="argument">*maximum_steps</span>)</span></dt><dd>Gets/sets the maximum number of inference steps allowed.</dd><dt><span class="dullCode"><span class="procedureName">call_with_step_limit</span>(<span class="argument">*maximum_steps</span>,&nbsp;<span class="argument">:Goal</span>)</span></dt><dd>Runs GOAL, using at most MAXIMUM_STEPS.</dd><dt><span class="dullCode"><span class="procedureName">benchmark</span>(<span class="argument">+goal</span>,&nbsp;<span class="argument">*count</span>)</span></dt><dd>Runs GOAL repeatedly, COUNT times.</dd><dt><span class="dullCode"><span class="procedureName">string_representation</span>(<span class="argument">?term</span>,&nbsp;<span class="argument">?string</span>)</span></dt><dd>Parses/unparses between TERM and STRING.</dd><dt><span class="dullCode"><span class="procedureName">starts_with</span>(<span class="argument">*substring</span>,&nbsp;<span class="argument">*string_or_symbol</span>)</span></dt><dd>The string or symbol's name begins with the specified substring.</dd><dt><span class="dullCode"><span class="procedureName">ends_with</span>(<span class="argument">*substring</span>,&nbsp;<span class="argument">*string_or_symbol</span>)</span></dt><dd>The string or symbol's name end with the specified substring.</dd><dt><span class="dullCode"><span class="procedureName">starts_with_one_of</span>(<span class="argument">*possible_first_chars_string</span>,&nbsp;<span class="argument">*string_or_symbol</span>)</span></dt><dd>The string or symbol's name begins with one of the characters in the specified string.</dd><dt><span class="dullCode"><span class="procedureName">contains_substring</span>(<span class="argument">*substring</span>,&nbsp;<span class="argument">*string_or_symbol</span>)</span></dt><dd>The string or symbol's name contains the specified string.</dd><dt><span class="dullCode"><span class="procedureName">plural_form</span>(<span class="argument">*singular</span>,&nbsp;<span class="argument">?plural</span>)</span></dt><dd>String plural is the plural form of string singular, using the default rules for English plurals.</dd><dt><span class="dullCode"><span class="procedureName">atom_string</span>(<span class="argument">?atom</span>,&nbsp;<span class="argument">?string</span>)</span></dt><dd>Atom has the same print name as string.</dd><dt><span class="dullCode"><span class="procedureName">game_object_name</span>(<span class="argument">?game_object</span>,&nbsp;<span class="argument">?name_symbol</span>)</span></dt><dd>True when name_symbol is the name of game_object.</dd><dt><span class="dullCode"><span class="procedureName">set</span>(<span class="argument">*predicate</span>,&nbsp;<span class="argument">*value</span>)</span></dt><dd>Forcibly asserts PREDICATE(VALUE) and retracts all other clauses for PREDICATE.</dd><dt><span class="dullCode"><span class="procedureName">display</span>(<span class="argument">?argument</span>,&nbsp;<span class="argument">&hellip;</span>)</span></dt><dd>Prints arguments to the console; string arguments are not quoted.</dd><dt><span class="dullCode"><span class="procedureName">displayln</span>(<span class="argument">?argument</span>,&nbsp;<span class="argument">&hellip;</span>)</span></dt><dd>Prints arguments to the console; string arguments are not quoted.</dd><dt><span class="dullCode"><span class="procedureName">write</span>(<span class="argument">?objectOrStream</span>,&nbsp;<span class="argument">[+Object]</span>)</span></dt><dd>Prints the value of OBJECT to the console.</dd><dt><span class="dullCode"><span class="procedureName">writeln</span>(<span class="argument">?objectOrStream</span>,&nbsp;<span class="argument">[+Object]</span>)</span></dt><dd>Prints the value of OBJECT to the console, along with a newline.</dd><dt><span class="dullCode"><span class="procedureName">nl</span></span></dt><dd>Prints a newline to the system console.</dd><dt><span class="dullCode"><span class="procedureName">log</span>(<span class="argument">?Term</span>,&nbsp;<span class="argument">&hellip;</span>)</span></dt><dd>Prints TERMS as a line in the Unity console.</dd><dt><span class="dullCode"><span class="procedureName">log_warning</span>(<span class="argument">?Term</span>,&nbsp;<span class="argument">&hellip;</span>)</span></dt><dd>Prints TERMS as a line in the Unity console.</dd><dt><span class="dullCode"><span class="procedureName">log_error</span>(<span class="argument">?Term</span>,&nbsp;<span class="argument">&hellip;</span>)</span></dt><dd>Prints TERMS as a line in the Unity console.</dd><dt><span class="dullCode"><span class="procedureName">open</span>(<span class="argument">*path</span>,&nbsp;<span class="argument">*mode</span>,&nbsp;<span class="argument">-stream</span>)</span></dt><dd>Opens a file for input or output.</dd><dt><span class="dullCode"><span class="procedureName">close</span>(<span class="argument">*stream</span>)</span></dt><dd>Closes an open file.</dd><dt><span class="dullCode"><span class="procedureName">read</span>(<span class="argument">*stream</span>,&nbsp;<span class="argument">-term</span>)</span></dt><dd>Reads an expression from an open stream.</dd><dt><span class="dullCode"><span class="procedureName">shell</span>(<span class="argument">command</span>,&nbsp;<span class="argument">arg_string</span>)</span></dt><dd>Runs a shell command; disabled outside of editor builds.</dd></dl>
</body>
</html>
